// generated by protoc-gen-tweact. DO NOT EDIT.
// source: {{.File.Name}} {{.File.Dependency | join ", "}}
{{- $pkg := .File.Package}}
{{- $src := splitList "/" .File.Name}}

{{- define "inlinecomment"}}{{- if .}}// {{. | trim | wrap 80 | replace "\n" "\n//"}}{{- end}}{{- end}}

{{- define "blockcomment"}}
{{- if .}}
/** 
 * {{. | trim | wrap 80 | replace "\n" "\n * "}}
 */
{{- end}}
{{- end}}

{{- range .File.Dependency}}
{{- with getProtoFile .}}
{{$path := splitList "/" .Name}}
{{- range $index, $element := $path }}
{{- if has $element $src }}
{{$path = without $path $element }}
{{- end}}
{{- end}}
import {
{{- range .MessageType}}
  {{.Name}},
{{- end}}
} from "./{{join "../" $path}}";
{{- end}}
{{- end}}

{{- range .File.EnumType}}

{{template "blockcomment" leadingComment .}}
export enum {{.Name}} {
  {{- range .Value}}
  {{template "blockcomment" leadingComment .}}
  {{.Name}} = {{.Number}}, {{template "inlinecomment" trailingComment .}}
  {{- end}}
}
{{template "inlinecomment" trailingComment .}}
{{- end}}

{{- range .File.MessageType}}
{{template "blockcomment" leadingComment .}}
export interface {{.Name}} {
  {{- range .Field}}
  {{template "blockcomment" leadingComment .}}
  {{- if isFieldRepeated .}}
  {{.Name}}: {{shortType .TypeName}}[]; {{template "inlinecomment" trailingComment .}}
  {{- else if .TypeName}}
  {{.Name}}: {{shortType .TypeName}}; {{template "inlinecomment" trailingComment .}}
  {{- else }}
  {{.Name}}: {{jsType .}}; {{template "inlinecomment" trailingComment .}}
  {{- end}}
  {{- end}}
}
{{- end}}

{{- range .File.Service}}
{{template "blockcomment" leadingComment .}}
{{- $svc := .}}

interface TwirpOptions {
  headers?: object
  fetcher?: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
}

interface TwirpService {
    request<Req,Res>(method: string, variables: Req, options?: TwirpOptions): Promise<Res>;
}

export class {{.Name}} implements TwirpService {
  prefix: string;
  fetcher: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
  options: TwirpOptions;
  constructor(prefix: string, options: TwirpOptions = {}) {
      this.prefix = prefix;
      this.options = options;

      if (typeof options.fetcher == "function") {
        this.fetcher = options.fetcher
      } else if (typeof window != "undefined" && typeof window.fetch == "function") {
        this.fetcher = window.fetch
      } else if (typeof fetch == "function") {
        this.fetcher = fetch
      } else {
        throw new Error("missing fetcher")
      }

      if (!prefix.trim()) {
        throw new Error("missing prefix")
      }
  }

  {{- range .Method}}
  {{template "blockcomment" leadingComment .}}
  {{.Name}} = (req: {{shortType .InputType}}) => this.request<{{shortType .InputType}}, {{shortType .OutputType}}>("{{$pkg}}.{{$svc.Name}}/{{.Name}}", req)
  {{- end}}

  request<Req,Res>(method: string, variables: Req, options: TwirpOptions = {}): Promise<Res> {
    return this.fetcher(this.prefix + method, {
        method: "POST",
        headers: {
            ...this.options.headers,
            ...options.headers,
            Accept: "application/json",
            "Content-Type": "application/json"
        },
        body: JSON.stringify(variables)
    })
        .then(res => res.json().then(body => ({ res, body })))
        .then(({ res, body }) => {
            if (!res.ok) {
                const err = new Error(body.msg) as TwirpError;
                err.status = res.status;
                err.code = body.code;
                err.meta = body.meta;
                throw err;
            }
            return body as Res;
        });
  }
}

interface TwirpError extends Error {
  status: number
  code: string
  meta: object
}

{{template "inlinecomment" trailingComment .}}
{{- end}}