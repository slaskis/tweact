package generator

import (
	"bytes"
	"path/filepath"
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

const header = `// generated by protoc-gen-tweact
import { withTwirp, TwirpService } from "@department/twirp-component";
`

func CreateClientAPI(d *descriptor.FileDescriptorProto) ([]*plugin.CodeGeneratorResponse_File, error) {
	var files []*plugin.CodeGeneratorResponse_File
	pkg := d.GetPackage()

	// TODO add comments
	// https://github.com/twitchtv/twirp/blob/master/internal/gen/typemap/typemap.go
	// https://github.com/pseudomuto/protokit/blob/master/parser.go

	// services are separate files and contains methods
	for _, svc := range d.Service {
		buf := bytes.NewBuffer(nil)

		// inject the runtime requirements
		buf.WriteString(header)

		// messages can be shared between services
		// (and are also only interfaces)
		// TODO move into shared file?
		for _, msg := range d.MessageType {
			var fields []field
			for _, f := range msg.Field {
				fields = append(fields, field{
					Name: f.GetJsonName(),
					Type: toTSType(f),
				})
			}
			err := messageTemplate.Execute(buf, message{
				Name:   *msg.Name,
				Fields: fields,
			})
			if err != nil {
				return nil, err
			}
		}

		// TODO also enums?
		for _, enum := range d.EnumType {
			err := enumTemplate.Execute(buf, enum)
			if err != nil {
				return nil, err
			}
		}

		buf.WriteString("\n")

		for _, met := range svc.GetMethod() {
			err := methodTemplate.Execute(buf, method{
				Package:    pkg,
				Service:    *svc.Name,
				InputType:  removePkg(*met.InputType),
				OutputType: removePkg(*met.OutputType),
				Name:       *met.Name,
			})

			if err != nil {
				return nil, err
			}
		}
		content := buf.String()

		name := filepath.Join(packageToPath(d.GetPackage()), svc.GetName()) + ".ts"
		file := plugin.CodeGeneratorResponse_File{
			Name:    &name,
			Content: &content,
		}
		files = append(files, &file)
	}

	return files, nil
}

func toTSType(f *descriptor.FieldDescriptorProto) string {
	tsType := "string"

	switch f.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
		descriptor.FieldDescriptorProto_TYPE_FIXED32,
		descriptor.FieldDescriptorProto_TYPE_FIXED64,
		descriptor.FieldDescriptorProto_TYPE_INT32,
		descriptor.FieldDescriptorProto_TYPE_INT64:
		tsType = "number"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		tsType = "string"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		tsType = "boolean"
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE,
		descriptor.FieldDescriptorProto_TYPE_ENUM:
		name := f.GetTypeName()

		// Google WKT Timestamp is a special case here:
		//
		// Currently the value will just be left as jsonpb RFC 3339 string.
		// JSON.stringify already handles serializing Date to its RFC 3339 format.
		//
		if name == ".google.protobuf.Timestamp" {
			tsType = "Date"
		} else {
			tsType = removePkg(name)
		}
	}

	if isRepeated(f) {
		tsType = tsType + "[]"
	}

	return tsType
}

func packageToPath(pkg string) string {
	return filepath.Join(strings.Split(pkg, ".")...)
}

func removePkg(s string) string {
	p := strings.Split(s, ".")
	return p[len(p)-1]
}

func isRepeated(field *descriptor.FieldDescriptorProto) bool {
	return field.Label != nil && *field.Label == descriptor.FieldDescriptorProto_LABEL_REPEATED
}

func scrub(str string) string {
	return strings.TrimSpace(strings.Replace(str, "\n ", "\n", -1))
}
